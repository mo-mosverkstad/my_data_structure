\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18} 

\usepackage{minted}
\usepackage{siunitx}

\begin{document}

\title{
    \textbf{Performance of Array Operations in C}
}
\author{Mo Wang}
\date{Spring 2026}

\maketitle

\section*{Introduction}

This report investigates the performance in terms of elapsed time of three array operations in C: random access of element, linear search of an element, and searching for duplicated elements in an array. As an introduction to algorithm and data structure, the purpose is to understand algorithms behavior such as time consumption in practice by measuring the elapsed time of each operation in arrays of different sizes. 

\section*{Benchmarking}

Measuring the elapsed time of an algorithm requires different methods, since it's not straightforward. 

For timing a function, the clock \texttt{CLOCK\_MONOTONIC} in C is used. The start and end time are timed using the function \texttt{clock\_gettime} that writes to variables \texttt{t\_start} as start time and \texttt{t\_end}, which are passed as pointer arguments.

The function \texttt{nano\_seconds} takes in the variables textt{t\_start} as start time and \texttt{t\_end} as pointers to \texttt{struct timespec} and calculate a time difference in nanoseconds in \\textt{long} type.

\begin{minted}{C}
  long nano_seconds(struct timespec *t_start, struct timespec *t_stop) {
      return (t_stop->tv_nsec- t_start->tv_nsec) + (t_stop->tv_sec- t_start->tv_sec)*1000000000;
  }
\end{minted}

 The example is shown for benchmarking random array accessing.

\begin{minted}{C}
  // Initial the variable int array[] and index_array[]
  struct timespec t_start, t_stop;
  int sum = 0;
     
  clock_gettime(CLOCK_MONOTONIC, &t_start);
  for (int i = 0; i < loop; i++){
    sum += array[index_array[i]]; // Algorithm operation
  }
  clock_gettime(CLOCK_MONOTONIC, &t_stop);

  long elapsed_time = nano_seconds(&t_start, &t_stop);
  // return elapsed time of batch benchmark
\end{minted}

However, clock precision for timing an algorithm is limited. This is mainly due to the limited clock precision of \texttt{CLOCK\_MONOTONIC} in C from the POSIX \texttt{time.h} header, usually in orders of hundreds of nanoseconds. Because of that, timing individual operations does not produce precise measurements and is thus unreliable, especially timing array access operation in orders of nanoseconds. To mitigate this issue, the same algorithm is executed over again multiple times, in my case 1024 times, while being batch timed. An average time can be calculated for estimating each amortized elapsed time for one individual operation.

Besides, the elapsed time differ in different computing systems and can also fluctuate when using the same computing system. Multiple factors can interfere with execution time, including hardware constraints, operating system time scheduler and background processes. To address this issue, same performance benchmark test is repeated a number of times, while an average elapsed time among the test result is calculated, in order to gain more accuracy.

In order to avoid compiler to optimize away performance benchmark code as dead code, the results of each operation are accumulated into a variable and read after the benchmark test loops. All arrays are allocated on the heap and initially filled with pseudo-random numbers in order to avoid cache locality and further optimizations that can obscure testing. For each benchmark, the array size is double as large as the previous one, in order to calculate a relevant scaling behavior and growth trend in a growing array size.

Finally, the reported numbers use an appropriate number of digits. The goal with the three benchmarks is not to claim unrealistic and arbitrary precision, but to illustrate clear performance trends as the input size increases.

\section*{Random access}

The rows in regular article mode are short - because it makes it
easier to read. Do not set the column width or margins explicitly, let
LaTeX decide what it should look like.

\begin{minted}{C}
  long random_access_benchmark(int n, int loop) {
      int *array = malloc(n * sizeof(int));
      int *index_array = malloc(loop * sizeof(int));
  
      for (int i = 0; i < n; i++){
          array[i] = i;
      }
      for (int i = 0; i < loop; i++){
          index_array[i] = rand() % n;
      }
  
      struct timespec t_start, t_stop;
      int sum = 0;
  
      clock_gettime(CLOCK_MONOTONIC, &t_start);
      for (int i = 0; i < loop; i++){
          sum += array[index_array[i]];
      }
      clock_gettime(CLOCK_MONOTONIC, &t_stop);
  
      free(array);
      free(index_array);
      
      // Force compiler to not let sum variable and its operation be treated as dead code
      if (sum == 0){
          return 0;
      }
      return nano_seconds(&t_start, &t_stop);
  }
\end{minted}


\begin{table}[h]
\begin{center}
\begin{tabular}{l|c}
\textbf{Size of array} & \textbf{Time}\\
\hline
  1024   &  2.3 ns \\
  2048   &  2.4 ns \\
  4096   &  2.4 ns \\
  8192   &  2.3 ns \\
  16384  &  2.4 ns \\
  32768  &  2.3 ns \\
  65536  &  2.4 ns \\
  131072 &  4.8 ns \\
\end{tabular}
\caption{Union and friends, list of 50000 elements, runtime in microseconds}
\label{tab:table1}
\end{center}
\end{table}

A diagram here

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      xlabel={Amount},
      ylabel={Time (\si{\nano\second})},
      width=12cm, height=8cm,
      grid=major,
      legend pos=north west
    ]
      % Your benchmark data
      \addplot+[
        mark=*,
        thick,
        color=blue
      ] coordinates {
        (1024,   2.28)
        (2048,   2.44)
        (4096,   2.41)
        (8192,   2.31)
        (16384,  2.37)
        (32768,  2.29)
        (65536,  2.35)
      };
      \addlegendentry{Random access benchmark}

      \addplot[red, thick, domain=1000:70000] {2.359};
      \addlegendentry{$y = 2.4$}
      
    \end{axis}
  \end{tikzpicture}
  \caption{Random access benchmark with fitted line(s)}
  \label{fig:random-access}
\end{figure}


\section*{Array search benchmark}

The rows in regular article mode are short - because it makes it
easier to read. Do not set the column width or margins explicitly, let
LaTeX decide what it should look like.

Don't use any fancy packages that will turn your report into a
Christmas tree, keep it simple!.

\begin{minted}{C}
  long search_benchmark(int n, int loop) {
    int *array = (int*) malloc(n*sizeof(int));
    for (int i = 0; i < n; i++)
        array[i] = rand()%(n*2);
    
    int *keys = (int*) malloc(loop*sizeof(int));
    for (int i = 0; i < loop; i++)
        keys[i] = rand()%(n*2);
    
    struct timespec t_start, t_stop;
    int sum = 0;
    clock_gettime(CLOCK_MONOTONIC, &t_start);
    for (int i = 0; i < loop; i++) {
        int key = keys[i];
        for (int j = 0; j < n; j++) {
            if (key == array[j]) {
                sum++;
                break;
            }
        }
    }
    clock_gettime(CLOCK_MONOTONIC, &t_stop);
    
    free(array);
    free(keys);
    
    long elapsed_time = nano_seconds(&t_start, &t_stop);
    return elapsed_time;
}
\end{minted}

\begin{table}[h]
\begin{center}
\begin{tabular}{l|c}
\textbf{Size of array} & \textbf{Time (approximate)}\\
\hline
  1024   &   1.7 µs   \\
  2048   &   3.3 µs   \\
  4096   &   6.4 µs   \\
  8192   &   13 µs    \\
  16384  &   26 µs    \\
  32768  &   51 µs    \\
  65536  &   100 µs   \\
  131072 &   200 µs   \\
\end{tabular}
\caption{Union and friends, list of 50000 elements, runtime in microseconds}
\label{tab:table1}
\end{center}
\end{table}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      xlabel={Amount},
      ylabel={Time (\si{\nano\second})},
      width=12cm, height=8cm,
      grid=major,
      legend pos=north west
    ]
      % Your benchmark data
      \addplot+[
        mark=*,
        thick,
        color=blue
      ] coordinates {
        (1024,   1679.10)
        (2048,   3268.07)
        (4096,   6436.80)
        (8192,   13010.31)
        (16384,  25751.70)
        (32768,  50693.34)
        (65536,  101850.42)
        (131072, 198295.30)
      };
      \addlegendentry{Array search benchmark}

      \addplot[red, thick, domain=0:131072] {1.5158*x + 647.33};
      \addlegendentry{$y = 1.5158x + 647.33$}
      
    \end{axis}
  \end{tikzpicture}
  \caption{Random access benchmark with fitted line(s)}
  \label{fig:random-access}
\end{figure}

\section*{Duplication}

\subsection*{sections}

Since this is a small report I can omit having numbered sections and
you do this by using section commands that end with a {\tt *} (for
example {\tt \textbackslash section* }). You can of course have
subsections etc. If you don't have numbers on the main sections,
don't add numbers to the subsections.

\begin{minted}{C}
  long random_access_benchmark(int n, int loop) {
      int *array = malloc(n * sizeof(int));
      int *index_array = malloc(loop * sizeof(int));
  
      for (int i = 0; i < n; i++){
          array[i] = i;
      }
      for (int i = 0; i < loop; i++){
          index_array[i] = rand() % n;
      }
  
      struct timespec t_start, t_stop;
      int sum = 0;
  
      clock_gettime(CLOCK_MONOTONIC, &t_start);
      for (int i = 0; i < loop; i++){
          sum += array[index_array[i]];
      }
      clock_gettime(CLOCK_MONOTONIC, &t_stop);
  
      free(array);
      free(index_array);
      
      // Force compiler to not let sum variable and its operation be treated as dead code
      if (sum == 0){
          return 0;
      }
      return nano_seconds(&t_start, &t_stop);
  }
\end{minted}

\begin{table}[h]
\begin{center}
\begin{tabular}{l|c}
\textbf{Size of array} & \textbf{Time (approximate)}\\
\hline
  1024   &  1.1 ms  \\  
  2048   &  3.7 ms  \\  
  4096   &  14 ms   \\ 
  8192   &  57 ms   \\ 
  16384  &  220 ms  \\  
  32768  &  890 ms  \\  
  65536  &  3.6 s   \\ 
  131072 &  14 s    \\
\end{tabular}
\caption{Union and friends, list of 50000 elements, runtime in microseconds}
\label{tab:table1}
\end{center}
\end{table}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      xlabel={Amount},
      ylabel={Time (\si{\nano\second})},
      width=12cm, height=8cm,
      grid=major,
      legend pos=north west
    ]
      % Your benchmark data
      \addplot+[
        mark=*,
        thick,
        color=blue
      ] coordinates {
        (1024,   1065420.8)
        (2048,   3684608)
        (4096,   14206248.96)
        (8192,   56628264.96)
        (16384,  224418447.36)
        (32768,  894779381.76)
        (65536,  3580590469.12)
        (131072, 14484434739.2)
      };
      \addlegendentry{Array search benchmark}

      \addplot[red, thick, domain=0:131072] {0.8506*x^2 - 1048*x + 6e6};
      \addlegendentry{$y = 0.8506x^2 - 1048x + 6 \cdot 10^6$}
      
    \end{axis}
  \end{tikzpicture}
  \caption{Random access benchmark with fitted line(s)}
  \label{fig:random-access}
\end{figure}


\subsection*{inserting code}

Code snippets are included using the package {\tt minted}. If you
want to include a program statement in running text you can do this
using for example teletype-text: {\tt List.sort()}.

\begin{minted}{rust}
  for i in 0..10{
    sum += i;
  }
\end{minted}

\end{document}
